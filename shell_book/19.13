In long-running scripts, here's a useful way to set (and unset) timestamping of commands:

    # timestamps.sh -- turn on command timestamping
    #
    # EXAMPLE
    #
    #   source timestamps.sh
    #   timestamps
    #   sleep 20
    #   timestamps off
    #   exit

    timestamps() {
      set +x
      [ "$1" = "off" ] && return 0
      PS4='== $(date)\n'
      set -x
      return 0
    }

When things aren't working, knowing where and when they failed can be a big
help.

I often use a logging function, wrapped around this, to collect all the IO.

        # logging.sh
        #
        # EXAMPLE:
        #
        #     $ cat foo
        #     source logging.sh
        #     ...     # a lot of stuff
        #     $ nohup foo 0<&- &> /dev/null &
        #     $ ls
        #     foo.LOG
        #     # and, after a while
        #     $ ls
        #     foo.ERR
        #
        # This last result means foo failed, and foo.ERR is the full log of
        # what went wrong and when.

        source timestamps.sh

        ERR=$PWD/$BASH_COMMAND.ERR
        rm -f $ERR
        LOG=$PWD/$BASH_COMMAND.LOG
        exec &>$LOG

        trap 'mv $LOG $ERR' ERR

        timestamps on
