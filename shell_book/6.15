dashes -c= 50
dashes -cx
  ->
  dashes -c = 50
  dashes -c x

  (Needs the spaces.)


for a complete remove
  -> for a complete listing


  (Typo -- probably from a global replacement.)


printf 'usage: %s [-c X ] [#]\n' $(basename $0) >&2
exit 2
  ->
  USAGE="usage ${0##*/} [-c X] [#]"
  die $USAGE

  (I often issue usage messages from more than one place, so I make a single
  $USAGE variable to ease maintenance.

  I use the shell ${VAR##pat} syntax to strip the basename, rather than forking
  a subshell and calling an external program, because, well, that's why it's
  there.  YMMV.)

CHAR='-'
while (( $# > 0 )
...
    -c) shift;
        CHAR=${1:--}
        ;;
      ...
  esac
  shift
  ...

  (As it stands, there's some logic that needs to be changed for the shifts.
  If it's called as "-c" with no character argument, you say that the default
  is a -, but then you do an extra shift after the esac, which fails --
  shifting off a non-existent arg is a failure -- and is a potential
  maintenance headache.

  Waiting to do the shift and the fall-back assignment

    while (( $# > 0 ))
    ...
        -c) [ "$2" ] && { CHAR=$2; shift; }

      esac
    shift
    : ${CHAR:=-}

    ...

  may make things a bit clearer and, thus, less error-prone. )
